package org.openedit.store.gateway;

import java.util.HashMap;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.dom4j.Element;
import org.openedit.Data;
import org.openedit.data.SearcherManager;
import org.openedit.money.Fraction;
import org.openedit.money.Money;
import org.openedit.store.Store;
import org.openedit.store.StoreException;
import org.openedit.store.orders.BaseOrderProcessor;
import org.openedit.store.orders.Order;
import org.openedit.store.orders.OrderState;
import org.openedit.store.orders.Refund;

import com.openedit.WebPageRequest;
import com.openedit.page.Page;
import com.openedit.page.manage.PageManager;
import com.openedit.users.UserManager;
import com.openedit.util.XmlUtil;
import com.stripe.Stripe;
import com.stripe.model.Charge;

public class StripeOrderProcessor extends BaseOrderProcessor
{

	private static final Log log = LogFactory.getLog(StripeOrderProcessor.class);
	protected PageManager fieldPageManager;
	protected XmlUtil fieldXmlUtil;
	protected BeanstreamUtil fieldBeanstreamUtil;

	public SearcherManager getSearcherManager()
	{
		return fieldSearcherManager;
	}

	public void setSearcherManager(SearcherManager fieldSearcherManager)
	{
		this.fieldSearcherManager = fieldSearcherManager;
	}

	protected UserManager fieldUserManager;
	protected SearcherManager fieldSearcherManager;

	public XmlUtil getXmlUtil()
	{
		if (fieldXmlUtil == null)
		{
			fieldXmlUtil = new XmlUtil();
		}
		return fieldXmlUtil;
	}

	public void setXmlUtil(XmlUtil inXmlUtil)
	{
		fieldXmlUtil = inXmlUtil;
	}

	

	public UserManager getUserManager()
	{
		return fieldUserManager;
	}

	public void setUserManager(UserManager inUserManager)
	{
		fieldUserManager = inUserManager;
	}

	public PageManager getPageManager()
	{
		return fieldPageManager;
	}

	public void setPageManager(PageManager inPageManager)
	{
		fieldPageManager = inPageManager;
	}

	protected boolean requiresValidation(Store inStore, Order inOrder)
	{
		
		if(inStore.get("gateway") != null && inStore.get("gateway").equals("stripe")){
			return true;
		}
		
		return false;
	}

	public void processNewOrder(WebPageRequest inContext, Store inStore, Order inOrder) throws StoreException
	{
		if (!requiresValidation(inStore, inOrder))
		{
			return;
		}
		String stripetoken = inContext.getRequestParameter("stripeToken");
		inOrder.setProperty("stripetoken", stripetoken);
		// "AUTH_ONLY"); //AUTH_CAPTURE, AUTH_ONLY, CAPTURE_ONLY, CREDIT, VOID,
		// PRIOR_AUTH_CAPTURE.
		if (inStore.isAutoCapture())
		{
			process(inStore, inOrder, "AUTH_CAPTURE");
		}
		else
		{
			process(inStore, inOrder, "AUTH_ONLY");
		}
	}

	protected void process(Store inStore, Order inOrder, String inType) throws StoreException
	{
		log.info("processing order with Stripe");

		// See examples at http://www.jcommercesql.com/anet/
		// load properties (e.g. IP address, username, password) for
		// accessing authorize.net
		// load customer address info from order (in case needed for AVS)
		
		if(inOrder.get("stripetoken") == null){
			log.error("cannot find stripetoken, aborting");
			OrderState orderState = inStore.getOrderState(Order.REJECTED);
			orderState.setDescription("Configuration error: stripe token not found");
			orderState.setOk(false);
			inOrder.setOrderState(orderState);
			return;	
		}
		
		Map<String, Object> chargeParams = new HashMap<String, Object>();
		Money totalprice = inOrder.getTotalPrice();
		//stripe connect: use access_token generated by oauth in place of 
		//secretkey; also define application fee (application_fee parameter)
		Data setting = getSearcherManager().getData(getCatalogId(), "catalogsettings", "stripe_access_token");
		if (setting!=null && setting.get("value")!=null && inStore.get("fee_structure")!=null){
			String access_token = setting.get("value");
			String fee_structure = inStore.get("fee_structure");
			//fee structure - if less than 1 then it's a percentage
			//(so we can never have a flat rate fee that's less than $1.00)
			//otherwise it's a flat rate
			// need to make sure our fee does not exceed total price
			double rate = Double.parseDouble(fee_structure);
			if (rate <= 0.0d){
				log.error("fee structure is invalid, aborting");
				OrderState orderState = inStore.getOrderState(Order.REJECTED);
				orderState.setDescription("Configuration error: fee structure is invalid");
				orderState.setOk(false);
				inOrder.setOrderState(orderState);
				return;
			}
			Money fee = new Money(rate);
			if (rate < 1.0d){
				fee = totalprice.multiply(new Fraction(rate));
			}
			totalprice = totalprice.subtract(fee);
			if (totalprice.isNegative()){
				log.error("configuration error: fee for processing is too big, aborting");
				OrderState orderState = inStore.getOrderState(Order.REJECTED);
				orderState.setDescription("Configuration error: fee structure is invalid");
				orderState.setOk(false);
				inOrder.setOrderState(orderState);
				return;
			}
			String feestring = fee.toShortString().replace(".", "").replace("$", "").replace(",", "");
			Stripe.apiKey = access_token;//does not matter if production or not
			chargeParams.put("application_fee",feestring);//amount in cents
		} else {
			//process as usual
			if(inStore.isProductionMode()){
				Stripe.apiKey = inStore.get("secretkey");
			} else{
				Stripe.apiKey = inStore.get("testsecretkey");
			}
		}
		String amountstring = totalprice.toShortString().replace(".", "").replace("$", "").replace(",", "");
		chargeParams.put("amount", amountstring);
		chargeParams.put("currency", "cad");
		chargeParams.put("card", inOrder.get("stripetoken")); // obtained with
		
		// Stripe.js
		Map<String,String> initialMetadata = new HashMap<String,String>();
		initialMetadata.put("email", inOrder.getCustomer().getEmail());
		chargeParams.put("description",inOrder.getOrderNumber());
		chargeParams.put("metadata", initialMetadata);
		try
		{
			Object c = Charge.create(chargeParams);
			OrderState orderState = inStore.getOrderState(Order.AUTHORIZED);
			// inOrder.setProperty("transactionid",
			// pairs.get("trnId").toString());
			orderState.setDescription("Your transaction has been authorized.");
			orderState.setOk(true);
			inOrder.setOrderState(orderState);
			

		}

		catch (Exception e)
		{
			OrderState orderState = inStore.getOrderState(Order.REJECTED);
			e.printStackTrace();
			orderState.setDescription("An error occurred while processing your transaction.");
			orderState.setOk(false);
			inOrder.setOrderState(orderState);
		}

	}

	public void captureOrder(WebPageRequest inContext, Store inStore, Order inOrder) throws StoreException
	{
		if (!requiresValidation(inStore, inOrder))
		{
			return;
		}
		process(inStore, inOrder, "");
	}

	@Override
	public void refundOrder(WebPageRequest inContext, Store inStore, Order inOrder, Refund inRefund) throws StoreException
	{
	//	getBeanstreamUtil().refund(inStore, inOrder, inRefund);
	}
}
